pub fn run() {
    // make_panic();
    panic_backtrace();
}

/// 使用 panic!() 处理不可恢复的错误使用这个宏，
/// Rust 会打印一个错误信息，展开并清理栈数据，接着退出
/// 出现这种情况的场景通常是检测到一些类型的 bug 而程序员并不知道怎么处理
// ----------------------------------------------------------------------------
/**
  panic 的行为模式有两种，
  -------------------------------------------------------------------------
    - 展开 (unwinding) : 这意味着 rust 会回溯和清理它所遇到的每一个函数的数据,
      这个过程中有很多工作需要做，
    - 终止(abort) : 着会不清理程序就直接退出，清理的工作交给操作系统来完成

    如果希望最终项目的运行文件越小越好，则终止方式是一个选择，当我们需要在 release
    版本中需要这样来处理 panic 的时候，需要在 cargo.toml 中配置

     [profile.release]
     panic="abort"

*/
fn make_panic() {
    // 输出的错误信息会显示我们代码中指定的 panic 内容和行号
    panic!("crash and burn");
}

/// 我们设置环境变量来显示对应的 backtrace 信息
/// 运行代码的时候配置 环境变量 RUST_BACKTRACE 为一个非 0 值
/// RUST_BACKTRACE=1 cargo run
/// 这样将会得到完整的运行栈信息，你需要从这样的调用栈中找到问题
/// 并解决问题(例如本例中因为我们访问了超出界限的索引值)
/// ------------------------------------------------------------------------------
/// 这里还需要注意的一点是: RUST_BACKTRACE=1 这个环境变量生效需要启用 debug 标识
/// 当我们在命令行中使用 cargo build/run 时没有使用 `--release` 的时候 debug 标识
/// 默认时打开的，索引我们才能看到栈的详细信息
fn panic_backtrace() {
    let v = vec![1, 2, 3];
    v[99];
}
