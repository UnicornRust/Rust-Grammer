use std::fmt::Display;

/// 生命周期的运用
/// -----------------------------------------------------------------
/// 不同于 trait 确保类型具有我们期望的行为，生命周期则有助于确保引用
/// 在我们需要他们的时候一直有效，
///
pub fn run() {
    println!("----------------lifetime trait----------------");
    // 生命周期注解的概念
    concept_lifetime();

    // 生命周期注解在函数中的应用
    func_generic_lifetime();

    // 函数返回值并非参数引用是返回值应该具有所有权，而非引用
    param_not_return_lifetime();

    // 结构体中的生命周期注解
    struct_generic_lifetime();

    // 生命周期缺省规则
    lifetime_elsion();
}

/*
*  借用检查器：(brorrow checker) 它比较作用域来确保所有的借用都是有效的
------------------------------------------------------------------------
在下面的示例中，
 > 这里将 r 的生命周期标记为 'a  x 的生命周期被标记为 'b,
   内部的 'b 块比外部的生命周期 'a 小得多，在编译时，
   Rust 比较两个生命周期得大小，并发现 r 拥有生命周期 'a,
   不过它引用了一个拥有生命周期 'b 的对象，
   因为生命周期 'b 比生命周期 'a 要小，
   被引用的对象比它的引用者存在的时间更短 > 因此这段代码时无法编译的
{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}
*/

/*
* -------------------------------------------
* 看下面这段代码, 这里 x 拥有生命周期 'b, 比'a  要大,
* 这就意味着 r 可以引用 x: Rust 知道 r 中的引用
* 在 x 有效的时候也总是有效的。
*
let x = 5;            // ----------+-- 'b
                      //           |
let r = &x;           // --+-- 'a  |
                      //   |       |
println!("r: {}", r); //   |       |
                      // --+       |
*/
fn concept_lifetime() {
    {
        let x = 5;
        let r = &x;
        println!("r: {}", r);
    }
}

/// 函数中泛型的生命周期
fn func_generic_lifetime() {
    //
    let str_one = String::from("abcd");
    let str_two = "xyz";
    let result = longest(str_one.as_str(), str_two);
    println!("The longest string is {}", result)
}

// 获取两个字符串 slice 中较长的一个
// -------------------------------------------------------------------------------
// 这里函数获取作为引用的字符串 slice, 因为我们不希望 longest 函数获取参数的所有权
// 这会出现一个关于生命周期的错误，表示返回值需要一个泛型生命周期参数，因为 Rust
// 并不知道返回的引用是指向 x 或 y (具体指向哪一个，取决于输入的值)
// 同时我们也不知道传入的引用的具体生命周期，通过上述观察作用域的方式，
// 并不能保证返回的引用总是有效的
// ------------------------------------------------------------------------------=
// 为了解决上述问题，需要引入 <泛型生命周期参数> 来定义引用间的关系
// 以便借用检查器可以进行分析
/*
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
*/

/// ### 生命周期注解语法
/// ---------------------------------------------------------------------------------
/// 生命周期注解并不改变任何引用生命周期的长短, 与当函数签名中指定了泛型类型参数之后
/// 就可以接收任何类型一样，当指定了泛型生命周期后函数也能接收任何生命周期的引用。生命
/// 周期注解描述了多个引用生命周期相互的关系，而不影响生命周期.
///
/*
 > 语法
    - 生命周期参数名称必须以 `(')`  开头，
    - 其名称通常全是小写,类似于泛型名称非常短
    - 'a 是大多数人的选择使用的默认的名称
    - 生命周期注解位于引用的 & 之后
    - 使用一个空格来将引用类型于生命周期注解分开

 > 示例
    - &i32         // 引用
    - &'a i32      // 带有显式生命周期的引用
    - &'a mut i32  // 带有显示生命周期的可变引用

单个的声明周期注解本身没有什么意义，因为生命周期注解告诉 Rust 多个引用的
泛型生命周期参数如何相互联系，

例如:
    一个生命周期 'a 的 i32 的引用的参数 first, 还有另一个同样是生命周期'a
    的 i32 引用参数 second, 这两个生命周期注解意味着引用 first 和 second
    必须与这泛型生命周期存在得一样久.
*/

// 就向泛型参数需要声明在函数名与参数是列表之间的`<>`中一样，生命周期参数
// 也要声明, longest函数签名中想要表达的限制是(两个) 参数和返回的引用的生命
// 周期是相关的，也就是这两个参数和返回的引用存活的一样久. 因为他们都是 'a

// 这个函数生命周期表达的含义是： longest 函数返回的引用的生命周期与传入的该
// 函数的引用的生命周期的较小者一致，这些就是我们希望 Rust 分析代码时需要知道的
//
// 通过这个生命周期注解，我们并没有改变任何的引用的生命周期，而是指出任何不满足
// 这个约束条件的值都将被借用器拒绝，而 longest 函数也并不知道 x 和 y 具体会
// 存在多久，而只需要知道有某个可以被 'a 替代的作用域将会满足这个签名
//
// 函数中使用生命周期注解的时候，这些注解在函数签名中，不存在于函数体的任何代码中
// 生命周期注解称为了函数约定的一部分，非常像签名中的类型,这让编译器的工作变得简单
// 如果出现不满足条件的调用也会提示的更加准确
//
// 当具体的引用调用longest 函数的时候，被 'a 所替代的具体生命周期是
// x 的作用域和 y 的作用域相重叠的部分，换种说法就是 两者中较小的那一个.
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// 当从函数中返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配
// 如果没有指向任何一个参数，那么唯一可能就是它指向了一个在函数内部创建的值，它将
// 会是一个悬垂引用，因为它将会在函数结束时离开作用域，这样的代码是不能编译的。
//
// 出现的问题是 result 在 longest 函数结尾将离开作用域被清理，而尝试从函数返回一个
// result 的引用，无法指定生命周参数来改变悬垂引用， Rust 也不允许我们创建悬垂引用
//
// 在这样的情况下我们应该返回一个有所有权的数据类型，这样函数的调用者就需要负责清理
// 这个值了。
/*

fn longest2<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
*/

fn longest2(x: &str, y: &str) -> String {
    let mut result = String::from("really long string, ");
    result.push_str(x);
    result.push_str(" ");
    result.push_str(y);
    result.push_str("!");
    result
}

// 当我们返回值与参数无关的时候，我们应该返回一个所有权的类型
// 同时这也无关生命周期参数关联
fn param_not_return_lifetime() {
    let st1 = String::from("hello");
    let result;
    let st2;
    {
        st2 = String::from("world");
        result = longest2(&st1, &st2)
    }
    println!("The longest string is : {} ", result)
}

// 综上所述，生命周期语法是用于多个参数与其返回值的生命周期进行关联的，一旦他们形成了
// 某种关联，Rust 就有足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或违反内存
// 安全的行为.

/// ===================================================================
/// ### 结构体中的生命周期语法
/// ===================================================================

// 当我们定义一个包含引用的结构体，这需要我们为结构体中每一个引用添加
// 生命周期注解, 类似泛型参数，必须在结构体名称与 `{}` 之间的 `<>`中
// 先声明泛型生命周期参数。以便在结构体中使用生命周期参数。这个注解意
// 味着 ImportantExcerpt 实例不能比 part 字段中的引用存在的更久
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn struct_generic_lifetime() {
    let novel = String::from("Call me Ishmael. Some years age....");
    let first_sentence = novel.split('.').next().expect("Counld not find a '.'");
    let ipe = ImportantExcerpt {
        part: first_sentence,
    };
    println!("{}", ipe.part)
}

/// ===================================================================
/// ### 生命周期省略 (Lifetime Elision)
/// ===================================================================
/// > 被编码进 Rust 引用分析的模式被称为 <生命周期省略规则(lifetime elision relus)>，
///   这不是程序员需要遵守的规则，这些规则是一系列特定的场景，则是编译器会考虑代码是
///   否符合这些场景，如果符合，则不需要明确的指定生命周期, 随着 rust 的发展，更多的
///   明确的模式被编译到编译器中完全是有可能的，未来只会有更少的生命周期
///
/// > 编译器采用三条规则来判断何时生命周期不需要被明确的注解，第一条适用于输入生命周期
///   第二, 三条适用于输出生命周期, 如果检查完三条规则后任然存在没有计算的生命周期的引用
///   编译器将会停止并生成错误
///
/// > 输入生命周期(input lifetimes) : 函数或者方法的参数的生命周期
///    - 规则1：每个引用的参数都有它的生命周期参数，就是说有一个引用参数的函数就有一个
///    生命周期参数，有两个引用参数的函数就有两个不同的生命周期参数。
/// > 输出生命周期(output lifetimes) : 而返回值的生命周期被称为
///    - 规则2: 如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数
///    - 规则3: 如果方法有多个输入生命周期参数，并且其中一个是 `&self` 或者 `&mut self`
///      说明是个对像的方法，那么输出生命周期参数被赋予 self 的生命周期.
///
/// -------------------------------------------------------------------
///

// 第一条规则，每个引用有一个生命周期参数
// 第二条规则，只有一个生命周期参数的时候，所有输出生命周期参数被赋予输入生命周期
// 因此这个函数是满足可以不需要显示标注生命周期参数的规则
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    for (_, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..1];
        }
    }
    &s[..]
}

fn lifetime_elsion() {
    let sentence = String::from("test get sentence first world");
    let word = "hello";
    let a = first_word(sentence.as_str());
    let _a = first_word(&sentence[..]);
    let b = first_word(&word);
    let c = first_word(word);
    println!("{a}:{_a}:{b}:{c}")
}

// 之前使用的 longest 函数 有两个输入生命周期，一个输出生命周期，
// 第二条，第三条都不满足，因此需要显示的标明生命周期注解才能编译
//
//     fn longest(a: &str, b: &str) -> &str {}
// ->  fn longest<'a,'b>(a: '&a  str, b: '&b str) -> ? &str {}
// ->  后面两条都不满足，无法解析返回值（-> ? &str）生命周期，则抛出错误
// ->  panic()

//
/// ### 方法中定义的生命周期注解,
/// ----------------------------------------------------------------------
/// 声明和使用生命周期参数的位置依赖于生命周期参数是否同结构体字段和方法参数
/// 和返回值相关.
/// ----------------------------------------------------------------------
/// (实现方法时) 结构体字段的生命周期总是在 impl 关键字之后声明并在结构体名称
/// 之后被使用，因为这些生命周期时结构体类型的一部分。
/// impl 块中的方法签名中，引用可能与结构体中的引用相关联，也可能时独立的。
///

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}

// 上述 impl 块中， impl 之口的生命周期参数是必要的，不过因为第三条生命周期规则，
// level 的输出生命周期被赋予了 self 的生命周期
//
//
//
/// ### 静态生命周期
/// ----------------------------------------------------------------------
/// 生命周期中有一类比较特别的周期，`'static` 这样的生命周期存活于整个程序运行期间，
/// 所有的字符串字面值的生命周期都是 `'static`
/// > 通常我们会在错误帮助文本中见识过 'static 的生命周期建议，在我们将引用指定为
/// ’static 之前，应该认真考虑这个引用是否真的在整个程序的生命周期中都有效，以及
/// 你是否希望它存活这么久。大部分的推荐 'static 生命周期的错误信息都是尝试创建一个
/// 悬垂引用或者可用的生命周期不匹配的结果，在这种情况下的解决方案是修复这些问题
/// 而不是指定一个 'static 生命周期

// 这是一个生命周期与泛型类型同时使用的例子
// 生命周期泛型也是泛型，因此与泛型参数一起位于函数名称后的 <> 中
fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
where
    T: Display, // T 类型需要实现 Display trait, 因为函数中使用 {} 来展示它
{
    println!("Announcemet! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
